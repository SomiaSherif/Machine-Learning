#!/usr/bin/env python
# coding: utf-8

# In[81]:


import numpy as np
import pandas as pd

import matplotlib.pyplot as plt
import seaborn as sns

from tensorflow import keras
from keras.preprocessing.image import ImageDataGenerator as imgen
from keras.models import Model
from keras.layers import GlobalAveragePooling2D,Dense,Dropout,Input
from keras.applications.xception import Xception
from keras.applications.xception import preprocess_input
from keras.callbacks import ModelCheckpoint,EarlyStopping

from sklearn.metrics import classification_report,confusion_matrix
from sklearn.metrics import roc_curve, auc
from sklearn.metrics import roc_auc_score
import tensorflow as tf


# In[82]:


traingen = imgen(preprocessing_function=preprocess_input,
                zoom_range=0.2,
                 shear_range=0.2,
                 horizontal_flip=True,
                 validation_split=0.12
                )
testgen = imgen(preprocessing_function=preprocess_input)


# In[83]:


path="C:/Users/ranya\Downloads/archive (1)/afhq"


# In[84]:


tf.keras.preprocessing.image.load_img('C:/Users/ranya\Downloads/archive (1)/afhq/train/cat/flickr_cat_000018.jpg')


# In[85]:


trainds = traingen.flow_from_directory("C:/Users/ranya/Downloads/archive (1)/afhq/train",
                                      target_size=(128,128),
                                       seed = 123,
                                       batch_size=128,
                                       class_mode="categorical",
                                       subset="training"
                                      )
valds = traingen.flow_from_directory("C:/Users/ranya/Downloads/archive (1)/afhq/train",
                                     target_size=(128,128),
                                      seed =123,
                                      batch_size = 128,
                                      class_mode="categorical",
                                      subset="validation"
                                     )
testds = testgen.flow_from_directory("C:/Users/ranya/Downloads/archive (1)/afhq/val",
                                    target_size=(128,128),
                                      seed =123,
                                      batch_size = 128,
                                      class_mode="categorical",
                                     shuffle=False
                                    )


# In[86]:


from skimage import io
image = io.imread('C:/Users/ranya\Downloads/archive (1)/afhq/train/cat/flickr_cat_000018.jpg')  

# plotting the original image
i, (im1) = plt.subplots(1)
i.set_figwidth(15)
im1.imshow(image)


# In[87]:


i, (im1, im2, im3, im4) = plt.subplots(1, 4, sharey=True)
i.set_figwidth(20) 

im1.imshow(image)  #Original image
im2.imshow(image[:, : , 0]) #Red
im3.imshow(image[:, : , 1]) #Green
im4.imshow(image[:, : , 2]) #Blue
i.suptitle('Original & RGB image channels')


# In[88]:


import skimage
gray_image = skimage.color.rgb2gray(image)
plt.imshow(gray_image, cmap = 'gray')


# In[89]:


norm_image = (gray_image - np.min(gray_image)) / (np.max(gray_image) - np.min(gray_image))
plt.imshow(norm_image)


# In[90]:


from numpy import expand_dims
from keras.preprocessing.image import load_img
from keras.preprocessing.image import img_to_array
from keras.preprocessing.image import ImageDataGenerator

# convert to numpy array
data = img_to_array(image)

# expand dimension to one sample
samples = expand_dims(image, 0)

# create image data augmentation generator
datagen = ImageDataGenerator(width_shift_range=[-200,200])

# create an iterator
it = datagen.flow(samples, batch_size=1)
fig, im = plt.subplots(nrows=1, ncols=3, figsize=(15,15))

# generate batch of images
for i in range(3):
     image = next(it)[0].astype('uint8')
 
    # plot image
     im[i].imshow(image) 
        


# In[91]:


import cv2
image=cv2.imread("C:/Users/ranya\Downloads/archive (1)/afhq/train/cat/flickr_cat_000018.jpg")
image = image / 255
image


# In[92]:


classes = trainds.class_indices
classes = list(classes.keys())
classes


# In[93]:


dist = trainds.classes
sns.countplot(x=dist);


# In[94]:


def showImages(x,y):
    plt.figure(figsize=[15,11])
    for i in range(16):
        plt.subplot(4,4,i+1)
        plt.imshow(x[i])
        plt.title(classes[np.argmax(y[i])])
        plt.axis("off")
    plt.show()
    
x,y = next(trainds)
showImages(x,y)


# In[95]:


base_model = Xception(include_top = False,weights="imagenet",pooling="avg",input_shape=(128,128,3))

base_model.trainable = False


# In[96]:


image_input = Input(shape=(128,128,3))
x = base_model(image_input,training = False)
x = Dense(128,activation = "relu")(x)
image_output = Dense(3,activation="softmax")(x)
model = Model(image_input,image_output)


# In[97]:


model.compile(optimizer="adam",loss="categorical_crossentropy",metrics=["accuracy"])

# callbacks
my_calls = [EarlyStopping(monitor="val_accuracy",patience=3),
            ModelCheckpoint("xception_weights_tf_dim_ordering_tf_kernels_notop.h5",verbose= 1 ,save_best_only=True)]


# In[98]:


model.summary()


# In[99]:


hist = model.fit(trainds, epochs=1, validation_data=valds, callbacks=my_calls)


# In[100]:


model.evaluate(testds)


# In[101]:


plt.figure(figsize=(15,6))

plt.subplot(1,2,1)
plt.plot(hist.epoch,hist.history['accuracy'],label = 'Training')
plt.plot(hist.epoch,hist.history['val_accuracy'],label = 'validation')

plt.title("Accuracy")
plt.legend()

plt.subplot(1,2,2)
plt.plot(hist.epoch,hist.history['loss'],label = 'Training')
plt.plot(hist.epoch,hist.history['val_loss'],label = 'validation')

plt.title("Loss")
plt.legend()
plt.show()


# In[102]:


pred = model.predict(testds,verbose=1)


# In[103]:


pred = [np.argmax(i) for i in pred]


# In[104]:


y_test = testds.classes


# In[105]:


print(classification_report(pred,y_test))


# In[107]:


from sklearn.metrics import confusion_matrix, accuracy_score
cm = confusion_matrix(y_test, pred)
print(cm)
accuracy_score(y_test, pred)


# In[108]:


sns.heatmap(confusion_matrix(pred,y_test),annot = True, fmt = "d", cmap = "BuPu");


# In[111]:



import numpy as np
import matplotlib.pyplot as plt
from itertools import cycle

from sklearn import svm, datasets
from sklearn.metrics import roc_curve, auc
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import label_binarize
from sklearn.multiclass import OneVsRestClassifier
from sklearn.metrics import roc_auc_score

# Import some data to play with
#animal = datasets.load(path)
iris=datasets.load_iris()
dataset_url = 
data_dir = pathlib.Path(data_dir)
X = iris.data
y = iris.target

# Binarize the output
y = label_binarize(y, classes=[0, 1, 2])
n_classes = y.shape[1]

# Add noisy features to make the problem harder
random_state = np.random.RandomState(0)
n_samples, n_features = X.shape
X = np.c_[X, random_state.randn(n_samples, 200 * n_features)]

# shuffle and split training and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.5, random_state=0)

# Learn to predict each class against the other
classifier = OneVsRestClassifier(
    svm.SVC(kernel="linear", probability=True, random_state=random_state)
)
y_score = classifier.fit(X_train, y_train).decision_function(X_test)

# Compute ROC curve and ROC area for each class
fpr = dict()
tpr = dict()
roc_auc = dict()
for i in range(n_classes):
    fpr[i], tpr[i], _ = roc_curve(y_test[:, i], y_score[:, i])
    roc_auc[i] = auc(fpr[i], tpr[i])

# Compute micro-average ROC curve and ROC area
fpr["micro"], tpr["micro"], _ = roc_curve(y_test.ravel(), y_score.ravel())
roc_auc["micro"] = auc(fpr["micro"], tpr["micro"])


# In[70]:


plt.figure()
lw = 2
plt.plot(
    fpr[2],
    tpr[2],
    color="darkorange",
    lw=lw,
    label="ROC curve (area = %0.2f)" % roc_auc[2],
)
plt.plot([0, 1], [0, 1], color="navy", lw=lw, linestyle="--")
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel("False Positive Rate")
plt.ylabel("True Positive Rate")
plt.title("Receiver operating characteristic example")
plt.legend(loc="lower right")
plt.show()


# In[71]:


all_fpr = np.unique(np.concatenate([fpr[i] for i in range(n_classes)]))

# Then interpolate all ROC curves at this points
mean_tpr = np.zeros_like(all_fpr)
for i in range(n_classes):
    mean_tpr += np.interp(all_fpr, fpr[i], tpr[i])

# Finally average it and compute AUC
mean_tpr /= n_classes

fpr["macro"] = all_fpr
tpr["macro"] = mean_tpr
roc_auc["macro"] = auc(fpr["macro"], tpr["macro"])

# Plot all ROC curves
plt.figure()
plt.plot(
    fpr["micro"],
    tpr["micro"],
    label="micro-average ROC curve (area = {0:0.2f})".format(roc_auc["micro"]),
    color="deeppink",
    linestyle=":",
    linewidth=4,
)

plt.plot(
    fpr["macro"],
    tpr["macro"],
    label="macro-average ROC curve (area = {0:0.2f})".format(roc_auc["macro"]),
    color="navy",
    linestyle=":",
    linewidth=4,
)

colors = cycle(["aqua", "darkorange", "cornflowerblue"])
for i, color in zip(range(n_classes), colors):
    plt.plot(
        fpr[i],
        tpr[i],
        color=color,
        lw=lw,
        label="ROC curve of class {0} (area = {1:0.2f})".format(i, roc_auc[i]),
    )

plt.plot([0, 1], [0, 1], "k--", lw=lw)
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel("False Positive Rate")
plt.ylabel("True Positive Rate")
plt.title("Some extension of Receiver operating characteristic to multiclass")
plt.legend(loc="lower right")
plt.show()


# In[64]:


#y_test = np.array(y_test, dtype='float32')/255.0


# In[109]:


# multi-class classification
from sklearn.datasets import make_classification
from sklearn.multiclass import OneVsRestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import roc_curve
from sklearn.metrics import roc_auc_score

# generate 2 class dataset
X, y = make_classification(n_samples=1000, n_classes=3, n_features=20, n_informative=3, random_state=42)

# split into train/test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.4, random_state=42)

# fit model
clf = OneVsRestClassifier(LogisticRegression())
clf.fit(X_train, y_train)
pred = clf.predict(X_test)
pred_prob = clf.predict_proba(X_test)

# roc curve for classes
fpr = {}
tpr = {}
thresh ={}
n_class = 3

for i in range(n_class):    
    fpr[i], tpr[i], thresh[i] = roc_curve(y_test, pred_prob[:,i], pos_label=i)
    
# plotting    
plt.plot(fpr[0], tpr[0], linestyle='--',color='orange', label='Class 0 vs Rest')
plt.plot(fpr[1], tpr[1], linestyle='--',color='green', label='Class 1 vs Rest')
plt.plot(fpr[2], tpr[2], linestyle='--',color='blue', label='Class 2 vs Rest')
plt.title('Multiclass ROC curve')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive rate')
plt.legend(loc='best')
plt.savefig('Multiclass ROC',dpi=300);  


# In[ ]:




